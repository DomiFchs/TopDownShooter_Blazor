@page "/game"

@inject GameConnectionProvider GameConnectionProvider
@inject IDialogService DialogService
@inject NavigationManager NavigationManager
@implements IAsyncDisposable

<MudButton FullWidth="true" Disabled="_pressedReady" Color="Color.Primary" Variant="Variant.Filled" OnClick="SetReady">Ready</MudButton>
@if (_gameStarted) {
    
    @if (GameConnectionProvider.GameSettings is not null) {
        
    <MudAlert Severity="@(_focussed ? Severity.Info : Severity.Warning)">@(_focussed ? "Press WASD to Move and Enter to shoot!" : "Focus the Canvas to Play!")</MudAlert>
    <div class="d-flex justify-content-center">
        <div @onfocusin="() => SetFocus(true)" @onfocusout="() => SetFocus(false)" tabindex="0" @onkeydown="OnKeyDown" @onkeyup="OnKeyUp" @onkeypress="OnKeyPress">
            <BECanvas Width="@((long)GameConnectionProvider.GameSettings.FieldWidth)" Height="@((long)GameConnectionProvider.GameSettings.FieldHeight)" @ref="_canvasReference"></BECanvas>
        </div>
    </div>
    
    }
    @if (GameConnectionProvider.Owner is not null && GameConnectionProvider.Enemy is not null && GameConnectionProvider.CurrentSession is not null){
        <div class="d-flex justify-content-around">
            <div style="width: 20vw">
                <MudText>@GameConnectionProvider.Owner.UserName (You)</MudText>
                <MudProgressLinear Color="Color.Error" Rounded="true" Size="Size.Large" Value="@GameConnectionProvider.Owner.CurrentHealth" Max="@GameConnectionProvider.GameSettings.MaxPlayerHealth"/>
                <MudProgressLinear Color="Color.Warning" Rounded="true" Size="Size.Large" Value="@GameConnectionProvider.Owner.CurrentStamina" Max="@GameConnectionProvider.GameSettings.MaxPlayerStamina"/>
            </div>
            <div>
                <MudButton Disabled="true" Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.RemoveRedEye">@GameConnectionProvider.CurrentSession.SpectatorCount</MudButton>
            </div>
            <div style="width: 20vw">
                <MudText>@GameConnectionProvider.Enemy.UserName</MudText>
                <MudProgressLinear Color="Color.Error" Rounded="true" Size="Size.Large" Value="@GameConnectionProvider.Enemy.CurrentHealth" Max="@GameConnectionProvider.GameSettings.MaxPlayerHealth"/>
                <MudProgressLinear Color="Color.Warning" Rounded="true" Size="Size.Large" Value="@GameConnectionProvider.Enemy.CurrentStamina" Max="@GameConnectionProvider.GameSettings.MaxPlayerStamina"/>
            </div>
        </div>
    }
}
else {
    <MudText>Waiting for other player to go Ready...</MudText>
}

@code {

    private Canvas2DContext _canvasContext = null!;
    private BECanvasComponent _canvasReference = null!;
    
    private bool _pressedReady;
    private bool _focussed;
    private bool _gameStarted;
    
    private KeyMask _currentKeyMask;
    
    private CancellationTokenSource Cts { get; } = new();
    private Task? _gameLoop;

    #region Blazor Cycle Methods

    protected override async Task OnInitializedAsync() {
        await GameConnectionProvider.FetchInitialGameDataServerRpc();
        
        GameConnectionProvider.OnGameStarted += OnGameStarted;
        GameConnectionProvider.OnGameDataUpdated += RenderCanvasAsync;
        GameConnectionProvider.OnGameEnded += OnGameEnded;
    }
    
    public async ValueTask DisposeAsync() {
        await CastAndDispose(_canvasContext);
        if (GameConnectionProvider != null) await GameConnectionProvider.DisposeAsync();
        await CastAndDispose(Cts);

        return;

        static async ValueTask CastAndDispose(IDisposable? resource) {
            if (resource is IAsyncDisposable resourceAsyncDisposable)
                await resourceAsyncDisposable.DisposeAsync();
            else
                resource?.Dispose();
        }
    }
    
    #endregion
    
    #region Game Lifecycle Methods
    
    private async Task OnGameStarted() {
        _gameStarted = true;
        _gameLoop = Task.Run(async () => await GameLoop(Cts.Token));
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnGameEnded(Player player) {
        var parameters = new DialogParameters<GameOverDialog> {
            { "Winner", player },
            { "OnLeave", GameConnectionProvider.DisconnectServerRpc(Cts.Token) }
        };
        await DialogService.ShowAsync<GameOverDialog>("Game Ended!", parameters , new DialogOptions() { MaxWidth = MaxWidth.Large, FullWidth = true, CloseOnEscapeKey = false, DisableBackdropClick = true});
    }

    private async Task GameLoop(CancellationToken ct) {
        while (!ct.IsCancellationRequested) {
            await GameConnectionProvider.UpdateGameDataServerRpc(ct);
            await Task.Delay(10, ct);
        }
    }
    
    #endregion

    #region CanvasRendering
    
    private async Task RenderCanvasAsync(Player localPlayer, Player enemy, List<Projectile>? projectiles) {
        _canvasContext = await _canvasReference.CreateCanvas2DAsync();
        await _canvasContext.SetFillStyleAsync("green");
        await _canvasContext.FillRectAsync(0, 0, GameConnectionProvider.GameSettings.FieldWidth, GameConnectionProvider.GameSettings.FieldHeight);
        await RenderPlayerWithWeapon(localPlayer);
        await RenderPlayerWithWeapon(enemy);

        await _canvasContext.SetFillStyleAsync("black");

        if (projectiles == null) {
            await InvokeAsync(StateHasChanged);
            return;
        }
        
        foreach (var projectile in projectiles) {
            await _canvasContext.FillRectAsync(projectile.X, projectile.Y, projectile.Size, projectile.Size);
        }
        
        await InvokeAsync(StateHasChanged);
    }

    private async Task RenderPlayerWithWeapon(Player player) {
        await _canvasContext.SetFillStyleAsync("black");
        await _canvasContext.FillRectAsync(player.X, player.Y, GameConnectionProvider.GameSettings.PlayerWidth, GameConnectionProvider.GameSettings.PlayerHeight);
        await _canvasContext.SetFillStyleAsync("gray");
        await DrawWeapon(player);
    }

    private async Task DrawWeapon(Player player) {
        var weaponSizeX = 30;
        var weaponSizeY = 10;

        var weaponX = player.X;
        var weaponY = player.Y;

        var direction = player.LastDirection;

        if (direction == KeyMask.Up) {
            (weaponSizeX, weaponSizeY) = (weaponSizeY, weaponSizeX);
            weaponY -= weaponSizeY;
            await _canvasContext.FillRectAsync(weaponX, weaponY, weaponSizeX, weaponSizeY);
            return;
        }

        if (direction == KeyMask.Down) {
            (weaponSizeX, weaponSizeY) = (weaponSizeY, weaponSizeX);
            weaponY += GameConnectionProvider.GameSettings.PlayerHeight;
            await _canvasContext.FillRectAsync(weaponX, weaponY, weaponSizeX, weaponSizeY);
            return;
        }

        if (direction == KeyMask.Left) {
            weaponX -= weaponSizeX;
            await _canvasContext.FillRectAsync(weaponX, weaponY, weaponSizeX, weaponSizeY);
            return;
        }

        if (direction == KeyMask.Right) {
            weaponX += GameConnectionProvider.GameSettings.PlayerWidth;
            await _canvasContext.FillRectAsync(weaponX, weaponY, weaponSizeX, weaponSizeY);
            return;
        }

        if (direction == (KeyMask.Up | KeyMask.Left)) {
            await DrawDiagonalWeapon(weaponX, weaponY - weaponSizeY, -1, -1, weaponSizeX, weaponSizeY);
            return;
        }

        if (direction == (KeyMask.Up | KeyMask.Right)) {
            await DrawDiagonalWeapon(weaponX + GameConnectionProvider.GameSettings.PlayerWidth, weaponY - weaponSizeY, 1, -1, weaponSizeX, weaponSizeY);
            return;
        }

        if (direction == (KeyMask.Down | KeyMask.Left)) {
            await DrawDiagonalWeapon(weaponX - weaponSizeX, weaponY + GameConnectionProvider.GameSettings.PlayerHeight, -1, 1, weaponSizeX, weaponSizeY);
            return;
        }

        if (direction == (KeyMask.Down | KeyMask.Right)) {
            await DrawDiagonalWeapon(weaponX + GameConnectionProvider.GameSettings.PlayerWidth, weaponY + GameConnectionProvider.GameSettings.PlayerHeight, 1, 1, weaponSizeX, weaponSizeY);
        }
    }
    
    private async Task DrawDiagonalWeapon(float x, float y, int xDirection, int yDirection, int weaponSizeX, int weaponSizeY) {
        var weaponPartsCount = 2;
        var weaponPartSize = weaponSizeX / 3;
        var weaponPartX = x - xDirection * weaponPartSize + weaponPartSize; // Adjusted initial X position
        var weaponPartY = y - yDirection * weaponPartSize + weaponPartSize; // Adjusted initial Y position

        switch (xDirection) {
            case -1 when yDirection == -1:
                weaponPartX -= weaponPartSize*3;
                weaponPartY -= weaponPartSize*2;
                break;
            case 1 when yDirection == -1:
                weaponPartY -= weaponPartSize*2;
                break;
        }

        for (var i = 0; i < weaponPartsCount; i++) {
            await _canvasContext.FillRectAsync(weaponPartX, weaponPartY, weaponPartSize, weaponSizeY);
            weaponPartX += xDirection * weaponPartSize;
            weaponPartY += yDirection * weaponSizeY;
        }
    }
    
    #endregion
    
    #region InputHandling

    private async Task OnKeyDown(KeyboardEventArgs e) {
        if (!_gameStarted) return;

        switch (e.Key) {
            case "a" or "A":
                _currentKeyMask |= KeyMask.Left;
                break;
            case "d" or "D":
                _currentKeyMask |= KeyMask.Right;
                break;
            case "w" or "W":
                _currentKeyMask |= KeyMask.Up;
                break;
            case "s" or "S":
                _currentKeyMask |= KeyMask.Down;
                break;
            case "Shift":
                await GameConnectionProvider.SendSprintStateServerRpc(true, Cts.Token);
                break;
            default: return;
        }
        await GameConnectionProvider.UpdatePlayerInputServerRpc(_currentKeyMask, Cts.Token);
    }
    
    private async Task OnKeyUp(KeyboardEventArgs e) {
        if (!_gameStarted) return;

        switch (e.Key) {
            case "a" or "A":
                _currentKeyMask &= ~KeyMask.Left;
                break;
            case "d" or "D":
                _currentKeyMask &= ~KeyMask.Right;
                break;
            case "w" or "W":
                _currentKeyMask &= ~KeyMask.Up;
                break;
            case "s" or "S":
                _currentKeyMask &= ~KeyMask.Down;
                break;
            case "Shift":
                await GameConnectionProvider.SendSprintStateServerRpc(false, Cts.Token);
                break;
            default: return;
        }
        await GameConnectionProvider.UpdatePlayerInputServerRpc(_currentKeyMask, Cts.Token);
    }

    private async Task OnKeyPress(KeyboardEventArgs e) {
        if (!_gameStarted) return;
        
        if(e.Key != "Enter") return;
        await GameConnectionProvider.ShootServerRpc(Cts.Token);
    }
    
    #endregion
    
    #region Others
        private async Task SetReady() {
            _pressedReady = true;
            await GameConnectionProvider.ChangeReadyStateServerRpc(true, Cts.Token);
            await InvokeAsync(StateHasChanged);
        }

        private void SetFocus(bool focus) {
            _focussed = focus;
        }
    #endregion
}